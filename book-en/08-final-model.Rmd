# Final model

We end this section on GLMM with the evaluation of the fixed effects. We
first code potential models and compare them using AICc.

``` {.rsplus|}
mpl2 <- update(mpl1, . ~ . - rack) # model without rack
mpl3 <- update(mpl1, . ~ . - status) # model without status
mpl4 <- update(mpl1, . ~ . - amd:nutrient) # without amd:nutrient interaction
ICtab(mpl1,mpl2,mpl3,mpl4, type = c("AICc"))
#     dAICc df
# mpl1  0.0  10
# mpl4  1.4  9 
# mpl3  1.5  8 
# mpl2 55.0  9 
```

Alternatively, we can use the functions `drop1` and `dfun`, where dfun
converts the AIC values returned by the drop1 into ΔAIC values
(producing a similar table to `ICtab` above).

``` {.rsplus|}
(dd_LRT <- drop1(mpl1,test="Chisq"))
# Model:
#   total.fruits ~ nutrient * amd + rack + status + (1 | X) + (1 | popu) + (1 | gen)
#              Df    AIC   LRT   Pr(Chi)    
# <none>          5015.4                     
# rack          1 5070.5 57.083 4.179e-14 ***
# status        2 5017.0  5.612   0.06044 .  
# nutrient:amd  1 5016.8  3.444   0.06349 .  
# ---
#   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

(dd_AIC <- dfun(drop1(mpl1)))
#               Df   dAIC
# <none>           0.000
# rack          1 55.083
# status        2  1.612
# nutrient:amd  1  1.444
```

There is a strong effect of rack (a change in AIC of 55 if we remove
this variable), whereas the effects of status and of the interaction
term are weak (change in AIC when either is dropped is less than 2). We
can thus start by removing the non-signifi cant interaction term so that
we can test the main e ffects of nutrient and clipping.

``` {.rsplus|}
mpl2 <- update(mpl1, . ~ . - and:nutrient)

# Use AICc:
mpl3 <- update(mpl2, . ~ . - rack) # model without rack or interaction
mpl4 <- update(mpl2, . ~ . - status) # model without status or interaction
mpl5 <- update(mpl2, . ~ . - nutrient) # without nutrient or interaction
mpl6 <- update(mpl2, . ~ . - amd) # without clipping or interaction
ICtab(mpl2,mpl3,mpl4,mpl5,mpl6, type = c("AICc"))
#     dAICc df
# mpl2   0.0 9 
# mpl4   1.2 7 
# mpl6  10.2 8 
# mpl3  54.2 8 
# mpl5 135.6 8 

# Or use drop1:
(dd_LRT2 <- drop1(mpl2,test="Chisq"))
# Model:
#   total.fruits ~ nutrient + amd + rack + status + (1 | X) + (1 | popu) + (1 | gen)
#            Df    AIC     LRT   Pr(Chi)    
#   <none>      5016.8                      
#   nutrient  1 5152.5 137.688 < 2.2e-16 ***
#   amd       1 5027.0  12.218 0.0004734 ***
#   rack      1 5071.0  56.231 6.443e-14 ***
#   status    2 5018.1   5.286 0.0711639 .  
# ---
#   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

(dd_AIC2 <- dfun(drop1(mpl2)))
#           Df    dAIC
# <none>        0.000
# nutrient  1 135.688
# amd       1  10.218
# rack      1  54.231
# status    2   1.286

summary(mpl2)
```

Both the main effects of nutrient and clipping are strong (large change
in AIC of 135.6 (mpl5) and 10.2 (mpl6) if either nutrient or clipping
are dropped, respectively). Our fi nal model includes the fixed nutrient
(strong positive) and clipping (negative) effects, the nuisance
variables rack, the observation-level random e ffects (1 \| X) to
account for over-dispersion and the variation in overall fruit set at
the *population* and *genotype* levels.

\*\* CHALLENGE 10 \*\*

Using the *inverts* dataset (larval development times (PLD) of 74 marine
invertebrate and vertebrate species reared at different temperatures and
time), answer the following questions:

1.  What is the effect of feeding type and climate (fixed effects) on
    PLD?
2.  Does this relationship vary among taxa (random effects)?
3.  What is the best distribution family for this count data?
4.  Finally, once you determined the best distribution family,
    re-evaluate your random and fixed effects.

++++ Challenge: Solution 1\|

```{r, echo = TRUE, eval = FALSE}
# Load data
inverts <- read.csv("inverts.csv")
str(inverts)

mlm1 <- lm(PLD ~ temp*feeding.type, data=inverts)
anova(mlm1) # all variables are significant
```

++++

++++ Challenge: Solution 2\|

```{r, echo = TRUE, eval = FALSE}

# Response vs fixed effects
ggplot(inverts,aes(x=temp,y=log(PLD+1),colour=feeding.type)) +
  geom_point() +
  stat_summary(aes(x=as.numeric(temp)),fun.y=mean,geom="line") +
  theme_bw() +
  scale_color_manual(values=c("#3B9AB2","#F21A00")) + # from Wes Anderson Zissou palette
  facet_wrap(~taxon)

# Create new variables that represents every combination feeding type x temp x taxa (random effect)
inverts <- within(inverts,
{
  # taxon x feeding.type
  tft <- interaction(taxon,feeding.type,temp)
  tft <- reorder(tft, PLD, mean)
})

# Boxplot of total fruits vs new variable (feeding type x temp x taxa)
ggplot(data = inverts, aes(factor(x = tft),y = log(PLD))) +
  geom_boxplot(colour = "skyblue2", outlier.shape = 21, outlier.colour = "skyblue2") + 
  theme_bw() + theme(axis.text.x=element_text(angle=90)) + 
  stat_summary(fun.y=mean, geom="point", colour = "red") 
```

++++

++++ Challenge: Solution 3\|

```{r, echo = TRUE, eval = FALSE}

grpVars <- tapply(inverts$PLD, inverts$tft, var)
summary(grpVars)

grpMeans <- tapply(inverts$PLD,inverts$tft, mean)
summary(grpMeans)

# Quasi-Poisson
lm1 <- lm(grpVars~grpMeans-1) 
phi.fit <- coef(lm1)
# The -1 specifies a model with the intercept set to zero

# Negative binomial
lm2 <- lm(grpVars ~ I(grpMeans^2) + offset(grpMeans)-1)
k.fit <- 1/coef(lm2)
# Offset() used to specify that we want group means added as a term with its coefficient fixed to 1

# Non-parametric loess fit
Lfit <- loess(grpVars~grpMeans)

plot(grpVars ~ grpMeans, xlab="group means", ylab="group variances" )
abline(a=0,b=1, lty=2)
text(60,200,"Poisson")
curve(phi.fit*x, col=2,add=TRUE)
# bquote() is used to substitute numeric values in equations with symbols
text(60,800,
     bquote(paste("QP: ",sigma^2==.(round(phi.fit,1))*mu)),col=2)
curve(x*(1+x/k.fit),col=4,add=TRUE)
text(60,1600,paste("NB: k=",round(k.fit,1),sep=""),col=4)
mvec <- 0:120
lines(mvec,predict(Lfit,mvec),col=5)
text(50,1300,"loess",col=5)

# Poisson GLMM 
mp1 <- glmer(PLD ~ temp*feeding.type +
               (1|taxon),
             data=inverts, family="poisson")
overdisp_fun(mp1)
# ratio is significantly >1

# NB GLMM
mnb1 <- glmer.nb(PLD ~ temp*feeding.type +
                   (1|taxon),
                 data=inverts)
overdisp_fun(mnb1)
# Looks good!
```

++++

++++ Challenge: Solution 4\|

```{r, echo = TRUE, eval = FALSE}

# Re-evaluating random intercepts
summary(mnb1)$varcor

mnb1.taxless <- glm.nb(PLD ~ temp*feeding.type,
                       data=inverts)
# Here, because we are comparing a glmer with a glm, we must do something different than calling anova()
# to test importance of random intercept. We will compare the likelihood of each model:
NL1 <- -logLik(mnb1)
NL0 <- -logLik(mnb1.taxless)
devdiff <- 2*(NL0-NL1)
dfdiff <- attr(NL1,"df")-attr(NL0,"df")
pchisq(devdiff,dfdiff,lower.tail=FALSE)

# Could also look at dAIC to compare model with (mnb1) and without (mnb1.taxless) random effects
# Using AICtab() function
AICtab(mnb1,mnb1.taxless) 
# Large change in AIC if drop random intercept. Therefore, worth keeping this in.

# Diagnostic plots 
locscaleplot(mnb1)

# Plotting variance terms 
coefplot2(mnb1,ptype="vcov",intercept=TRUE,main="Random effect variance")

# Plot of fixed effects 
coefplot2(mnb1,intercept=TRUE,main="Fixed effect coefficient")

# Plotting random intercepts 
pp <- list(layout.widths=list(left.padding=0, right.padding=0))
r2 <- ranef(mnb1,condVar=TRUE)
d2 <- dotplot(r2, par.settings=pp)
grid.arrange(d2$taxon,nrow=1)

# Evaluate random slopes
mnb2 <- glmer.nb(PLD ~ temp*feeding.type +
                   (PLD|taxon),
                 data=inverts)
                 
# View variance-covariance components
summary(mnb2) # option 1
attr(VarCorr(mnb2)$taxon,"correlation") # option 2
printvc(mnb2) # option 3
# Strong correlation between random effects -> not enough power to test random slopes

# Re-evaluating fixed effects 
# Note: to run the drop1 we need to speficy the theta parameter and run the NB model with glmer:
theta.mnb1 <- theta.md(inverts$PLD, fitted(mnb1), dfr = df.residual(mnb1))
mnb1 <- glmer(PLD ~ temp*feeding.type +
                (1|taxon),
              data=inverts, family=negative.binomial(theta=theta.mnb1))

(dd_LRT <- drop1(mnb1,test="Chisq"))
(dd_AIC <- dfun(drop1(mnb1)))
# dAIC when feeding.type x temp interaction is dropped is greater than 2, suggest to keep 
# interaction in model
```

++++