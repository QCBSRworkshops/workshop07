---
title: "Atelier 6: modèles linéaires à effets mixtes"
subtitle: "Série d'ateliers R du CSBQ"
author: "Centre de la science de la biodiversité du Québec"
output:
  xaringan::moon_reader:
    includes:
      in_header: qcbsR-header.html
    lib_dir: assets
    seal: true
    css: ["default", "qcbsR.css", "qcbsR-fonts.css"]
    nature:
      beforeInit: "qcbsR-macros.js"
      highlightLines: true
      highlightStyle: github
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  fig.width = 6, fig.height = 6,
  fig.retina = 3,
  fig.align = 'center'
)
options(repos=structure(c(CRAN="http://cran.r-project.org")))
```

class: inverse, center, middle

```{r install_pkgs, message = FALSE, warning = FALSE, include = FALSE, results = 0}
# Standard procedure to check and install packages and their dependencies, if needed

list.of.packages <- c("ggplot2", 
                   "lme4", 
                   "AICcmodavg", 
                   'MASS', 
                   'vcdExtra', 
                   'bbmle', 
                   'DescTools')

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

if(length(new.packages) > 0) {
  install.packages(new.packages, dependencies = TRUE) 
  print(paste0("The following package was installed:", new.packages)) 
} else if(length(new.packages) == 0) {
    print("All required packages were already installed previously.")
}

# Load all required libraries at once
lapply(list.of.packages, require, character.only = TRUE, quietly = TRUE)
```

# À propos de cet atelier

[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=repo&message=dev&color=6f42c1&logo=github)](https://github.com/QCBSRworkshops/workshop06)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=wiki&message=06&logo=wikipedia)](https://wiki.qcbs.ca/r_atelier6)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=06&color=red&logo=html5)](https://qcbsrworkshops.github.io/workshop06/workshop06-fr/workshop06-fr.html)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=06&color=red&logo=adobe-acrobat-reader)](https://qcbsrworkshops.github.io/workshop06/workshop06-fr/workshop06-fr.pdf)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=script&message=06&color=2a50b8&logo=r)](https://qcbsrworkshops.github.io/workshop06/workshop06-fr/workshop06-fr.R)

---

# Packages requis

* [ggplot2](https://cran.r-project.org/package=ggplot2)
* [lme4](https://cran.r-project.org/package=lme4)
* [AICcmodavg](https://cran.r-project.org/package=AICcmodavg)
* [MASS](https://cran.r-project.org/package=MASS)
* [vcdExtra](https://cran.r-project.org/package=vcdExtra)
* [bbmle](https://cran.r-project.org/package=bbmle)
* [DescTools](https://cran.r-project.org/package=DescTools)


<br>

```{r eval = FALSE}
install.packages(c("ggplot2", 
                   "lme4", 
                   "AICcmodavg", 
                   'MASS', 
                   'vcdExtra', 
                   'bbmle', 
                   'DescTools'))
```

---

# Objectifs d'apprentissage
<br>

##### 1. Comprendre ce que sont les modèles linéaires à effets mixtes (MLMs)

##### 2. Comprendre leur pertinence notamment pour les sciences de la biodiversité

##### 3. Apprendre à utiliser les MLMs dans R
    - Exploration des données
    - Construction du modèle *a priori*
    - Coder les modèles potentiels
    - Sélection du meilleur modèle
    - Validation du modèle
    - Interprétation et visualisation des résultats


---
# Question

.alert[** Est-ce que la position trophique des poissons augmente avec leur taille?**
]

Pour répondre, 3 espèces ont été sélectionnées et dix individus par espèce ont été mesurés (longueur corporelle) dans six lacs différents.

.center[ ![:scale 75%](images/fig_1_qcbs_wiki.png) ]



---
# Familiarisez vous avec le jeu de données
<br>

1. Ouvrez le jeu de données,

2. Ouvrez le script de l'atelier dans R,

3. Visualisez la relation entre taille et position trophique.

--

<br>

```{r, eval = TRUE}
fish.data <- read.csv('data/qcbs_w6_data.csv', stringsAsFactors = TRUE)
head(fish.data)
```


---
# Visualisation avec toutes les données

<br>

```{r, echo= FALSE}
library(ggplot2)
fish.data <- read.csv('data/qcbs_w6_data.csv')

# thème simplifié
fig <- theme_bw() + theme(panel.grid.minor=element_blank(), panel.grid.major=element_blank(), panel.background=element_blank()) +
  theme(strip.background=element_blank(), strip.text.y = element_text()) + theme(legend.background=element_blank()) +
  theme(legend.key=element_blank()) + theme(panel.border = element_rect(colour="black", fill=NA))

# Faites les trois graphiques suivants pour explorer les données
plot <- ggplot(aes(Fish_Length,Trophic_Pos),data = fish.data)

# Graphique 1 - Toutes les données
plot + geom_point() + xlab("Length (mm)") + ylab("Trophic Position") + labs(title="All Data") + fig
```

---
# Visualisation de l'ensemble des données

<br>

```{r, eval= FALSE}
# thème simplifié
fig <- theme_bw() + theme(panel.grid.minor=element_blank(),
    panel.grid.major=element_blank(), panel.background=element_blank()) +
    theme(strip.background=element_blank(), strip.text.y = element_text()) +
    theme(legend.background=element_blank()) +
    theme(legend.key=element_blank()) +
    theme(panel.border = element_rect(colour="black", fill=NA))

# Faites les trois graphiques suivants pour explorer les données
plot <- ggplot(aes(Fish_Length,Trophic_Pos),data = fish.data)

# Graphique 1 - Toutes les données
plot + geom_point() + xlab("Length (mm)") + ylab("Trophic Position") + labs(title="All Data") + fig
```


---
# Visualisation par espèce

```{r}
# Graphique 2 - Par espèce
plot + geom_point() + facet_wrap(~ Fish_Species) + xlab("Length (mm)") + ylab("Trophic Position") +
   labs(title="By Species") + fig
```

---
# Visualisation par Lake

```{r}
# Graphique 3 – Par lac
plot + geom_point() + facet_wrap(~ Lake) + xlab("Length (mm)") + ylab("Trophic Position") +
   labs(title="By Lake") + fig
```


---
# Pourquoi choisir un MLM?

**Discussion de groupe**

* Est-ce qu'on s'attend à ce que, pour toutes les espèces, la position trophique augmente avec la longueur corporelle?

    * Exactement de la même façon?

<br>

--

* Est-ce qu'on s'attend à ce que ces relations soient pareilles entre les lacs?

    * Comment pourraient-elles différer?

---
# Pourquoi choisir un MLM?

<br>

.large[**Comment pourrions-nous analyser ces données?**]

--

<br>

**Option 1. Séparer**:

- Faire une analyse séparée pour chaque espèces et chaque lac

<br>

**Option 2. Regrouper**:

- Faire une seule analyse en ignorant les variables espèces et lac


---
# Pourquoi choisir un MLM?

.pull-left[![](images/fig_5_w5.png) ]

.pull-right[
**Option 1. Séparer**
* Estime 6 intercepts et 6 pentes pour chaque espèces (i.e. 6 lacs)

* Taille d'échantillon *n* = 10 pour chaque analyse (i.e. 10 poissons/espèces/lac)

* Peu de chances de détecter un effet a cause de la faible taille d’échantillon *n*
]

---
# Pourquoi choisir un MLM?

.pull-left[![](images/fig_6_w5.png)]

.pull-right[
**Option 2. Regrouper:**
* Très grande taille d'échantillon!

* Et la pseudoreplication? (les poissons d'un même lac et d'une même espèce sont corrélés).

* Beaucoup de bruit! Une partie doit être due aux effets de l'espèce et du lac.
]

---
# Pourquoi choisir un MLM?


* Pour **notre question**, on veut seulement savoir s'il y a un **effet général de la longueur corporelle sur la position trophique**,

* Ceci pourrait varier faiblement par espèce à cause de différents taux de croissance et/ou par lac à cause de différences dans la disponibilité de nourriture. **On ne s'intéresse pas directement à ces facteurs non mesurés, mais on doit contrôler leur effet dans le modèle**.

--

<br>

Les MLMs sont un **compromis entre séparer et regrouper**. Ils:

1. Prendre entre compte de la variabilité spécifique pour chaque espèce et chaque lac (séparer) mais en calculant moins de paramètres;

2. Utilisent toutes les données disponibles (regrouper) tout en contrôlant les différences entre les lacs et les espèces (pseudo-replication).

---
# Pourquoi choisir un MLM?

#### Effet fixe VS effet aléatoire

Dans la littérature des MLMs, vous rencontrerez souvent ces termes souvent. Il existe plusieurs façon de les présenter et nous vous présenterons ici celles que nous trouvons les plus faciles à appliquer.

--

##### Effet fixe

* Les données proviennent de tous les niveaux possibles d'un facteur (variable qualitative),

* On souhaite émettre des conclusions à propos des niveaux du facteur d'où les données proviennent.

--

##### Effet aléatoire

* Seulement des variables qualitatives = facteur aléatoire;

* Permet de structurer le processus d'erreur.

---
# Pourquoi choisir un MLM?
<br>

#### Comment fonctionnent les MLMs?
<br>

**A.** Permet aux intercepts et/ou aux pentes d'être considérés comme propre à une population donnée (**effet aléatoire**), e.g. par lac et/ou par espèce

<br>

**B.** Les intercepts, les pentes et leur intervalle de confiance sont ajustés pour **prendre en compte la structure des données**.


---
# Effet aléatoire sur l'intercept
<br>

<img style="float: right; width:50%;margin: 1%" src="images/fig_7_w5.png">

On fait la supposition que les intercepts proviennent d'une distribution normale et on a seulement besoin d'estimer la moyenne (intercept général) et l'écart type de la distribution normale (effet aléatoire) au lieu d'estimer un intercept par espèce (ce qui rajoute 2 paramètres).

<br><br>

Au lieu d'estimer d'estimer un intercept par espèce (trois paramètres pour 3 espèces) on estime un intercept générale et un effet aléatoire soit 2 paramètres. Avec $n$ espèce, dans le premier cas on estime $n-1$ paramètres
alors qu'on reste à 2 paramètres dans le second cas!




---
# Effet aléatoire sur l'intercept
<br><br>

<img style="float: right; width:50%;margin: 1%" src="images/fig_8_w5.png">
Même principe pour les lacs

Estime 2 paramètres (moyenne et écart-type) au lieu de 6 intercepts.

Cela économise des degrés de liberté (moins d’estimation de paramètres sont nécessaires)



---
# Effet aléatoire sur la pente
<br><br>

<img style="float: right; width:50%;margin: 1%" src="images/fig_9_w5.png">
Le même principe s’applique aux pentes qui varient selon un facteur donné, juste plus difficile à visualiser.

Comme pour les intercepts, seuls la moyenne et l’écart-type des pentes sont estimés au lieu de trois pentes distinctes.

---
# Tenir compte de la structure des données
<br>

Si une certaine espèce ou un lac est peu représenté (faible $n$) dans les données, le modèle va accorder plus d'importance au modèle groupé pour estimer l'intercept et la pente de cette espèce ou de ce lac.

.center[![:scale 60%](images/fig_12_w5.png) ]

---
# Tenir compte de la structure des données
<br><br>

* Les intervalles de confiance des intercepts et pentes sont ajustés pour tenir compte de la pseudo-replication basée sur le **coefficient de corrélation intra-classe (CCI)**.

* Combien de variation y a-t-il dans chaque groupe VS entre les groupes ?


---
# Tenir compte de la structure des données


.pull-left[
**CIC élevé**

![](images/fig_10_w5.png)

les points provenant d'un même lac sont traités comme une seule observation car très corrélés

![:faic](arrow-right) petite taille effective de l'échantillon et grands intervalles de confiance pour la pente et l'intercept.
]

.pull-right[
**CIC faible**

![](images/fig_11_w5.png)

les points provenant d'un même lac sont traités indépendamment car peu corrélés

![:faic](arrow-right) grande taille effective de l'échantillon et petits intervalles de confiance pour la pente et l'intercept.
]

---
# Question / défi ![:cube]()

<br>

**Comment le CIC et l'intervalle de confiance seront affectés dans ces deux scénarios ?**

**Q1.** Les positions trophiques des poissons ne varient pas entre les lacs

<br>

**Q2.** Les positions trophiques des poissons sont similaires dans les lacs mais différentes entre les lacs

---
# Solution ![:cube]()

<br>

**Q1.** La position trophique ne varie pas entre les lacs?

.alert[R1. CIC faible, petits intervalles de confiances]

<br>

--

**Q2.** La position trophique est similaire dans un lac mais différente entre les lacs ?

.alert[R2. CIC élevé, grands intervalles de confiance]

---
# Comment implémenter un MLM dans R ?

<br>


<img style="float: right; width:32%;margin: 1%" src="images/lego.jpg">
###### Étape 1: Construction du modèle *a priori* et exploration des données

<br>

**Étape 2:** Coder les modèles potentiels et sélection du meilleur modèle

<br>

**Étape 3:** Validation du modèle

<br>

**Étape 4:** Interprétation et visualisation des résultats




---
# Étape 1 - exploration des données
<br>

* Modèle basé sur connaissance *a priori*:

  * Nous voulons déterminer si la position trophique peut être prédite par la longueur corporelle, tout en prenant en compte la variation entre les espèces et les lacs

  * Donc nous voulons un modèle qui ressemble a ceci:

$$PT_{ijk} \sim Longueur_i + Lac_j + Espèce_k + \varepsilon$$


---
# Étape 1 - exploration des données

**Les données ont-elles la bonne structure?**

```{r}
data <- read.csv('data/qcbs_w6_data.csv')
str(data)
```

.comment[**Il est recommandé de faire le ménage de votre espace de travail (`rm.list()`) avant de construire un modèle**.]


---
# Étape 1 - exploration des données

**Regardez la distribution des échantillons pour chaque facteur**:

```{r}
table(fish.data$Lake)
table(fish.data$Fish_Species)
```

.comment[Ce jeu de données est parfaitement équilibré, mais les **modèles mixtes peuvent analyser les plans expérimentaux non équilibrés**, comme c'est souvent le cas en écologie!]


---
# Étape 1 - exploration des données

Regardez la distribution des variables continues

```{r, fig.width=10, fig.height=4}
par(mfrow=c(1,2), mar = c(4,4,1,1))
hist(fish.data$Fish_Length)
hist(fish.data$Trophic_Pos)
```

.small[Des déviations majeures pourraient causer des problèmes d'hétéroscédasticité. Si nécessaire, faites des transformations. Dans ce cas-ci, **les données semblent correctes**.]


---
# Étape 1 - exploration des données

**Vérification de la colinéarité entre vos variables explicatives**

Le problème avec les prédicteurs colinéaires est simplement qu'ils expliquent la même chose, alors leur effet sur la variable réponse sera confondu dans le modèle.

Dans cet exemple, il n’y a pas de risque de colinéarité avec seulement une variable continue. Si vous aviez une autre variable continue (Var2), une façon simple de vérifier la colinéarité est:

```{r, eval = FALSE}
plot(data)

cor(var1, var2)
```


---
# Question / défi ![:cube]()

Quelles mesures supplémentaires aurions-nous pu prendre sur le terrain et qui auraient pu être fortement corrélées avec la longueur corporelle?

--

> Un exemple est la masse du poisson – c’est une variable fortement corrélée avec la longueur du poisson. Par conséquent, nous ne voulons pas inclure ces deux variables dans le même modèle.


---
# Étape 1 - exploration des données

**Considérez l'échelle de vos données**

* Si deux variables dans un même modèle ont des échelles très différentes, il est probable que le modèle mixte indique un problème de convergence en essayant de calculer les paramètres.

* La [correction Z](https://fr.wikipedia.org/wiki/Cote_Z_(statistiques) standardise les variables et résout ce problème (fonction `scale()` dans R) :

$$z = \frac{(x-\bar{x})}{\sqrt{\text{var}(x)}}$$


---
# Étape 1 - exploration des données

**Considérez l'échelle de vos données**

* Longueur corporelle ![:faic](arrow-right) Longue échelle

* Position trophique ![:faic](arrow-right) Courte échelle

---
# Étape 1 - exploration des données

**Considérez l'échelle de vos données**

* Parce que nos données ont des échelles très différentes, on applique la **correction Z**

```{r}
#Longueur corrigée, ""à la main"
fish.data$Z_Length <- (fish.data$Fish_Length-mean(fish.data$Fish_Length))/sd(fish.data$Fish_Length)

#Position trophique corrigée, avec scale
fish.data$Z_TP<- scale(fish.data$Trophic_Pos)
```


---
# Étape 1 - exploration des données

Pour savoir si un modèle mixte est nécessaire pour vos données, vous devez déterminer s'il est important de prendre en compte l'effet aléatoire de facteurs qui pourraient influencer la relation qui vous intéresse (dans notre cas, lac et espèce)

Nous pouvons le faire en :

1. Créant un modèle linéaire sans les facteurs qui pourraient avoir un effet aléatoire

2. Calculant les résidus de ce modèle linéaire

3. Produisant un graphique de la valeur des résidus en fonction des niveaux des facteurs potentiellement aléatoires

---
# Étape 1 - exploration des données


1. Créer un modèle linéaire sans les facteurs
```{r}
lm.test <- lm(Z_TP ~ Z_Length, data = fish.data)
```

2. Calculer les résidus de ce modèle linéaire
```{r}
lm.test.resid <- rstandard(lm.test)
```

---
# Exploration des données

Représentez graphiquement la valeur des résidus en fonction des niveaux des facteurs

```{r, fig.width=10, fig.height=5, eval = FALSE}
par(mfrow=c(1,2))

plot(lm.test.resid ~ as.factor(fish.data$Fish_Species),
     xlab = "Species", ylab = "Standardized residuals")

abline(0, 0, lty = 2)

plot(lm.test.resid ~ as.factor(fish.data$Lake),
     xlab = "Lake", ylab = "Standardized residuals")

abline(0, 0, lty = 2)
```

---
# Exploration des données

Représentez graphiquement la valeur des résidus en fonction des niveaux des facteurs

```{r, fig.width=10, fig.height=5, echo = FALSE}
par(mfrow=c(1,2), mar = c(4,4,1,1))
plot(lm.test.resid ~ as.factor(fish.data$Fish_Species),
     xlab = "Species", ylab = "Standardized residuals")
abline(0, 0, lty = 2)
plot(lm.test.resid ~ as.factor(fish.data$Lake),
     xlab = "Lake", ylab = "Standardized residuals")
abline(0, 0, lty = 2)
```

.alert[Ces patrons suggèrent qu'il y a de la variance résiduelle qui pourrait être expliquée par ces facteurs, et ils devraient donc être inclus dans le modèle]

---
# Comment implémenter un MLM dans R ?

<br>

<img style="float: right; width:32%;margin: 1%" src="images/lego.jpg">
Étape 1: Construction du modèle *a priori* et exploration des données

<br>

###### Étape 2: Coder les modèles potentiels et sélection du meilleur modèle

<br>

Étape 3: Validation du modèle

<br>

Étape 4: Interprétation et visualisation des résultats


---
# Étape 2 - coder les modèles

###### Traduisons notre modèle...

$$PT_{ijk} \sim Longueur_i + Lac_j + Espèce_k + \varepsilon$$

###### ... En code R

```{r, include = FALSE}
library(lme4)
```

```{r, eval = FALSE}
library(lme4)
lmer(Z_TP ~ Z_Length + (1 | Lake) + (1 | Fish_Species),
     data = fish.data, REML = TRUE)
```

--

* `lmer` ![:faic](arrow-right) fonction "linear mixed model" du package `lme4`
* `(1 | Lake)` ![:faic](arrow-right) indique que les intercepts peuvent varier
* `REML = TRUE` ![:faic](arrow-right) méthode d'estimation

---
# Note à propos de la méthode d'estimation

REML (Restricted Maximum Likelihood) est la méthode par défaut dans la fonction `lmer` (voir `?lmer`).

Il est à noter que l'estimateur de l’écart-type du maximum de vraisemblance (ML, pour Maximum Likelihood) est biaisé d’un facteur $(n-2) / n$. La méthode REML corrige ce biais.


- On devrait comparer les **modèles d'effets aléatoires nichés avec REML**

- Tandis qu'on devrait comparer les **modèles nichés à effets fixes avec ML**


---
# Étape 2 -  coder et sélectionner le meilleur modèle

<br>

##### Comment faire si on souhaite que la pente puisse varier ?

.center[
![](images/fig_22_w5.png)
]



---
# Étape 2 -  coder et sélectionner le meilleur modèle

<br>

##### Plus généralement

- `(1 | Lake)` effet aléatoire par lac sur l'ordonnée à l'origine
- `(1 + Z_Length | Lake)` effet aléatoire par lac sur la pente à l'origine et la
pente (NB: (`Z_Length | Lake)` donne le même résultat)
- `(-1 + Z_Length | Lake)` pour avoir uniquement l'effet aléatoire sur la pente
- `(1 | Lake) + (1 | Species)`  pour des effets aléatoires croisés
- `(1 | Lake:Fish_Species)` pour utiliser l'interaction entre 2 facteurs groupant
- si votre jeu de données inclus des effets nichés, vous pouvez utiliser `/`
pour les déclarer, e.g. `(1 | facteur1 / facteur2)` si `facteur2` est niché dans `facteur1` ([voir ![:faic](stack-exchange)](https://stats.stackexchange.com/questions/228800/crossed-vs-nested-random-effects-how-do-they-differ-and-how-are-they-specified))



---
# Défi 3 ![:cube]()

Réécrivez le code suivant de façon à ce que les **pentes** de la relation position trophique en fonction de longueur corporelle **varient par lac et par espèces**:

```{r}
lmer(Z_TP ~ Z_Length + (1 | Lake) + (1 | Fish_Species),
     data = fish.data, REML = TRUE)
```



---
# Solution ![:cube]()

<br>

```{r}
lmer(Z_TP ~ Z_Length + (1 + Z_Length | Lake) + (1 + Z_Length | Fish_Species),
     data = fish.data, REML = TRUE)
```


---
# Étape 2 -  coder et sélectionner le meilleur modèle

<br>

* Pour déterminer si vous avez construit le meilleur modèle mixte base sur vos connaissances a priori, vous devez comparer ce modèle a priori aux autres modèles alternatifs,

* Avec le jeu de données sur lequel vous travaillez, il y a plusieurs modèles alternatifs qui pourraient mieux correspondre à vos données.

---
# Défi 4 ![:cube]()

Faites une liste de 7 modèles alternatifs qui pourraient être comparés à celui-ci:

```{r, eval = FALSE}
lmer(Z_TP ~ Z_Length + (1 | Lake) + (1 | Fish_Species),
     data = fish.data, REML = TRUE)
```

.comment[Note: Si nous avions différents effets fixes entre les modèles, nous aurions dû indiquer `REML=FALSE` pour les comparer avec un méthode de vraisemblance comme l'AIC. Ici, vous devez rapporter les estimations des paramètres du "meilleur" modèle en utilisant `REML=TRUE`]


---
# Solution ![:cube]()


* Nous allons aussi construire le **modèle linéaire de base** `lm()` parce qu'il est toujours utile de voir la variation dans les valeurs de AICc.

```{r}
M0 <- lm(Z_TP ~ Z_Length, data = fish.data)
```

* Par contre, pour comparer ce modèle aux MLMs, il est important de .alert[changer la méthode d'estimation à ML (REML=FALSE)] parce que `lm()` n'utilise pas la même méthode d'estimation que `lmer()`
  - Démontrer que les résultats de la méthode des moindres carrés (least squares) est équivalente aux résultats de la méthode ML pour les modèles linéaires de bases!

---
# Solution

```{r}
# Modele linéaire de base
M0 <- lm(Z_TP ~ Z_Length, data = fish.data)
# modèle complet avec variation des intercepts
M1 <- lmer(Z_TP ~ Z_Length + (1 | Fish_Species) + (1 | Lake), data = fish.data, REML = FALSE)
# modèle complet avec variation des intercepts et de pentes
M2 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species) + (1 + Z_Length | Lake),
           data = fish.data, REML = FALSE)
# Pas d'effet lac, les intercepts varient par espèces
M3 <- lmer(Z_TP ~ Z_Length + (1 | Fish_Species), data = fish.data, REML = FALSE)
# Pas d'effet espèces, les intercepts varient par lac
M4 <- lmer(Z_TP ~ Z_Length + (1 | Lake), data = fish.data, REML = FALSE)
# Pas d'effet de lac, les intercepts et les pentes varient par espèces
M5 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species), data = fish.data, REML = FALSE)
# Pas d'effet de l'espèces, les intercepts et les pentes varient par lac
M6 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Lake), data = fish.data, REML = FALSE)
# modèle complet, variation d'intercept et pente par lac
M7 <- lmer(Z_TP ~ Z_Length + (1 | Fish_Species) + (1 + Z_Length | Lake),
           data = fish.data, REML = FALSE)
# modèle complet, variation d'intercept et pente par espèces
M8 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species) + (1 | Lake),
           data = fish.data, REML = FALSE)
```

![:faic](question) `boundary (singular) fit: see ?isSingular`, voir [cette discussion ![:faic](stack-exchange)]( https://stats.stackexchange.com/questions/185360/t-value-associated-with-nlme-lme4)


---
# Coder et sélectionner le meilleur modèle

* Maintenant que nous avons une liste de modèles potentiels, nous voulons les comparer entre eux pour sélectionner celui(ceux) qui a(ont) le plus de pouvoir prédictif

* Les modèles peuvent être comparés en utilisant la fonction `AICc` provenant du package `AICcmodavg`

* Le critère d'information Akaike (AIC) est une **mesure de qualité du modèle** pouvant être utilisée pour comparer les modèles

* `AICc` corrige pour le biais créé par les faibles tailles d'échantillon

---
# Coder et sélectionner le meilleur modèle

Pour trouver la valeur AICc d'un modèle, utilisez :

```{r}
library(AICcmodavg)
AICcmodavg::AICc(M1)
```


---
# Coder et sélectionner le meilleur modèle

Pour regrouper toutes les valeurs d'AICc dans un seul tableau, utilisez :

```{r}
AIC.table <- data.frame(Model = c(AICcmodavg::AICc(M0), 
                                  AICcmodavg::AICc(M1), 
                                  AICcmodavg::AICc(M2), 
                                  AICcmodavg::AICc(M3),
                                  AICcmodavg::AICc(M4), 
                                  AICcmodavg::AICc(M5), 
                                  AICcmodavg::AICc(M6),
                                  AICcmodavg::AICc(M7), 
                                  AICcmodavg::AICc(M8)), 
                        AICc = c("M0", "M1", 
                                 "M2", "M3", 
                                 "M4", "M5", 
                                 "M6", "M7", 
                                 "M8"))

```

---
# Coder et sélectionner le meilleur modèle

Que signifient ces valeurs d'AICc ?

```{r}
AIC.table
```

.small[Le modèle avec le plus petit AICc a le plus grand pouvoir prédictif

Souvent on considère que deux modèles à +/- 2 unités d'AICc de différence ont une pouvoir prédictif équivalent

Regardons de plus près M8 et M2. On peut exclure les autres car ils ont des AICc tellement plus élevés]

---
# Coder et sélectionner le meilleur modèle

Quelle est la structure du meilleur modèle?

```{r, eval = FALSE}
M8 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species) + (1 | Lake),
           data = fish.data, REML = FALSE)
```

L'intercept et l'effet de la longueur sur la position trophique peut varier selon l'espèce de poissons, mais seulement l'intercept peut varier par lac

<br>

.pull-left[![](images/fig_8_w5.png)]
.pull-right[![](images/fig_7_w5.png)]

---
# Coder et sélectionner le meilleur modèle

Une fois que les meilleurs modèles sont sélectionnés il faut remettre la méthode d'estimation a `REML=TRUE`

```{r}
M8 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species) + (1 | Lake),
           data = fish.data, REML = TRUE)

M2 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species) + (1 + Z_Length | Lake),
           data = fish.data, REML = TRUE)
```


---
# Défi 5 ![:cube]()

Prenez 2 minutes avec votre voisin pour étudier la structure du modèle M2.

Comment diffère-t-il de M8 d'un point de vue écologique?

Pourquoi n'est il pas surprenant que sa valeur d'AICc était la deuxième meilleure?

```{r, eval = FALSE}
M8 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species) + (1 | Lake),
           data = fish.data, REML = TRUE)

M2 <- lmer(Z_TP ~ Z_Length + (1 + Z_Length | Fish_Species) + (1 + Z_Length | Lake),
           data = fish.data, REML = TRUE)
```

---
# Solution


**Discussion de groupe...**

--

.alert[M2] La position trophique est une fonction de la longueur. L'intercept et l'effet de la longueur sur la position trophique peuvent varier selon l'espèce de poissons et le lac.

  * .small[les facteurs intrinsèques des espèces et des lacs sont à la base de relations différentes entre la position trophique et la longueur (i.e. pentes et intercepts)]

.alert[M8] La position trophique est une fonction de la longueur. L'intercept et l'effet de la longueur sur la position trophique peut varier selon l’espèce de poissons, mais seulement l'intercept peut varier par lac.

  * .small[seulement les facteurs intrinsèques des espèces sont responsables des différentes relations (i.e. pentes) et en moyenne, les positions trophiques pourraient être supérieures ou inférieures d’un lac à l’autre (e.g. intercepts).]



---
# Comment implémenter un MLM dans R?

<br>

<img style="float: right; width:32%;margin: 1%" src="images/lego.jpg">
Étape 1: Construction du modèle *a priori* et exploration des données

<br>

Étape 2: Coder les modèles potentiels et sélection du meilleur modèle

<br>

###### Étape 3: Validation du modèle

<br>

Étape 4: Interprétation et visualisation des résultats



---
# Étape 3 - validation du modèle


Vous devez vérifier que le modèle respecte toutes les suppositions de base:

1. Vérifier l'homogénéité de la variance
  - Faire un graphique des valeurs prédites en fonction des valeurs résiduelles

2. Vérifier l'indépendance des résidus
  - Graphique des résidus VS chaque covariable du modèle
  - Graphique des résidus VS chaque covariable non incluse du modèle

<img style="float: right; width:32%;margin: 1%" src="images/lego.jpg">
3. Vérifier la normalité
  - Histogramme


---
# Étape 3 - validation du modèle

1- Vérifier l'homogénéité de la variance

```{r, fig.width=4.5, fig.height=4.5, echo = -1}
par(mar=c(4,4,.5,.5))
plot(resid(M8) ~ fitted(M8), xlab = 'Valeurs pérdites', ylab = 'Résidus normalisés')
abline(h = 0, lty = 2)
```

Étendue homogène des résidus ![:faic](arrow-right) la supposition est respectée!

---
# Étape 3 - validation du modèle

1- Vérifier l'homogénéité de la variance

.center[
![](images/resid-plots.gif)
]

---
# Étape 3 - validation du modèle

2- Vérifier l'indépendance des résidus avec chaque covariable

```{r, fig.width=11, fig.height=4.5, eval = FALSE}
par(mfrow = c(1,3), mar=c(4,4,.5,.5))

plot(resid(M8) ~ fish.data$Z_Length, xlab = "Longueur", ylab = "Résidus normalisés")
abline(h = 0, lty = 2)

boxplot(resid(M8) ~ Fish_Species, data = fish.data, xlab = "Espèces", ylab = "Résidus normalisés")
abline(h = 0, lty = 2)

boxplot(resid(M8) ~ Lake, data = fish.data, xlab = "Lacs", ylab = "Résidus normalisés")
abline(h = 0, lty = 2)
```

---
# Étape 3 - validation du modèle

2- Vérifier l'indépendance des résidus avec chaque covariable

```{r, fig.width=12, fig.height=4.5, echo = FALSE}
par(mfrow = c(1,3), mar=c(4,4,.5,.5), cex.lab = 1.5)
plot(resid(M8) ~ fish.data$Z_Length, xlab = "Longueur", ylab = "Résidus normalisés")
abline(h = 0, lty = 2)
boxplot(resid(M8) ~ Fish_Species, data = fish.data, xlab = "Espèces", ylab = "")
abline(h = 0, lty = 2)
boxplot(resid(M8) ~ Lake, data = fish.data, xlab = "Lacs", ylab = "")
abline(h = 0, lty = 2)
```

Étendue homogène des résidus autour de 0 ![:faic](arrow-right) pas de patron des résidus en fonction de la variable, la supposition est respectée!

.comment[Note: Les regroupements de données sont dus à la structure des données, où des poissons de seulement 5 classes de taille  (grand, petit, et trois groupes entre les deux) étaient capturés.]

---
# Étape 3 - validation du modèle

2- Vérifier l'indépendance des résidus avec chaque covariable

- Graphique des résidus VS chaque covariable non incluse du modèle

  - Si vous observez des patrons dans ce graphique, vous saurez qu'il y a de la variation dans votre jeu de données qui pourrait être expliquée par ces covariables. Vous devriez considérer d'inclure ces variables dans votre modèle.

  - Puisque dans notre cas, nous avons inclus toutes les variables mesurées dans notre modèle, nous ne pouvons pas faire cette étape.

---
# Étape 3 - validation du modèle

3- Vérifier la normalité des résidus

* Des résidus suivant une distribution normale indiquent que le modèle n'est pas biaisé

```{r, fig.height=5, fig.width=5}
hist(resid(M8))
```


---
# Comment implémenter un MLM dans R ?

<br>

<img style="float: right; width:32%;margin: 1%" src="images/lego.jpg">
Étape 1: Construction du modèle *a priori* et exploration des données

<br>

Étape 2: Coder les modèles potentiels et sélection du meilleur modèle

<br>

Étape 3: Validation du modèle

<br>

###### Étape 4: Interprétation et visualisation des résultats


---
# Étape 4 - interprétation et visualisation

```{r, eval = FALSE}
summ_M8 <- summary(M8)
summ_M8
```

---
# Étape 4 - interprétation et visualisation


```{r, echo = FALSE}
summ_M8 <- summary(M8)
summary(M8)
```


---
# Étape 4 - interprétation et visualisation

    # Random effects:
    #  Groups       Name        Variance Std.Dev. Corr
    #  Lake         (Intercept) 0.20500  0.4528
    #  Fish_Species (Intercept) 0.86621  0.9307
    #               Z_Length    0.02464  0.1570   1.00
    #  Residual                 0.05040  0.2245

- `Groups`: facteurs groupant,
- `Name`:
  - `(Intercept)` pour l'ordonnée à l'origine,
  - ou le nom de la variable sur lequel porte l'effet mixe dans le cas d'une pente aléatoire, (`Z_length` dans notre exemple)
- `Variance` la variance estimée de l'effet (`Std.Dev.` est l'écart type de cette valeur)
- `Corr` indique la corrélation entre la pente aléatoire et l'ordonnée à l'origine aléatoire pour un groupement donné (voir [cette discussion ![:faic](stack-exchange)](https://stats.stackexchange.com/questions/320978/understanding-and-coding-random-intercept-correlation-lmer))


---
# Étape 4 - interprétation et visualisation

    # Fixed effects:
    #              Estimate Std. Error t value
    # (Intercept) -0.000906   0.568493  -0.002
    # Z_Length     0.422270   0.092170   4.581

Cette partie présente l'estimation des effet fixe. Une valeur de la statistique T (test de Student)](https://en.wikipedia.org/wiki/T-statistic) est retournée **sans p-value** (c'est un choix des auteurs du package, voir pourquoi dans [cette discussion](https://stats.stackexchange.com/questions/185360/t-value-associated-with-nlme-lme4)).

Cette statistique peut-être utilisée telle quelle. Vous pouvez aussi calculer
l’intervalle de confiance (IC) à 95% avec cette table en utilisant

$$ IC = Estimate \pm 1.96Std.Error $$

Si 0 est dans cet interval, alors le paramètre n’est pas significativement
différente de zéro au seuil $\alpha$ = 0.05.



---
# Étape 4 - interprétation et visualisation

<br>

##### Quelques fonctions utiles

- `coef(M8)` et `ranef(M8)` retourne les effets aléatoires du modèle M8

- `coef(summary(M8))` retourne les effets fixes

- `sigma(M8)` retourne l’écart type de la variance résiduelle

- `fitted(M8)` retourne les valeurs prédites par le modèle

- `residuals(M8)` retourne les résidus





---
# Défi 6 ![:cube]()

<br>

1. Quelle est la pente et son intervalle de confiance de la variable Z_Length dans le modèle M8?

2. Est-ce que la pente de Z_Length est significativement différente de 0 ?


---
# Solution ![:cube]()

<br>

1. Quelle est la pente et son intervalle de confiance de la variable Z_Length dans le modèle M8?

  - pente = 0.422;

  - limite supérieure de l’IC = 0.4223 + 0.09*1.96 = 0.5987

  - limite inférieure de l’IC = 0.4223 - 0.09*1.96 = 0.2459

2. Est-ce que la pente de Z_Length est significativement différente de 0 ?

  - Oui, car l'IC [0.2459, 0.5987] n'inclut pas 0


---
# Défi 7 ![:cube]()

* Il est possible de visualiser graphiquement les différentes intercepts et pentes du modèle pour mieux interpréter les résultats

Prenez 2 minutes pour réfléchir aux différentes façons pour représenter les résultats de M8.

*Indice: considérez les différents "niveaux" du modèle*


---
# Solution ![:cube]()

a) Figure avec toutes les données regroupées

b) Figure par espèce

c) Figure par lac

---
# Solution ![:cube]()

Pour faire ces figures, il nous faut:

- Les coefficients du modèle complet qui sont dans le résumé du modèle

```{r}
summ_M8$coefficients
```

- Intercept = $`r summ_M8$coefficients[1,1]`$
- Pente = $`r summ_M8$coefficients[2,1]`$


---
# Solution ![:cube]()

Pour faire ces figures, il nous faut:

- Les coefficients pour chaque niveau du modèle qu'on obtient avec la fonction `coef`

```{r}
coef(M8)
```

---
# Solution ![:cube]()

a) Figure avec toutes les données regroupées
```{r, eval = FALSE}
library(ggplot2)

# Thème ggplot simplifié
fig <- theme_bw() +
  theme(panel.grid.minor=element_blank(), panel.grid.major=element_blank(),
        panel.background=element_blank()) +
  theme(strip.background=element_blank(), strip.text.y = element_text()) +
  theme(legend.background=element_blank()) +
  theme(legend.key=element_blank()) +
  theme(panel.border = element_rect(colour = "black", fill=NA))

plot <- ggplot(aes(Z_Length, Z_TP), data = fish.data)
Plot_AllData <- plot + geom_point() +
  xlab("Longueur (mm)") + ylab("Position trophique") +
  labs(title = "Toutes les données") + fig

Plot_AllData + geom_abline(intercept = -.0009059, slope = 0.4222697)
```

---
# Solution ![:cube]()

a) Figure avec toutes les données regroupées
```{r, echo = FALSE}
plot <- ggplot(aes(Z_Length, Z_TP), data = fish.data)
Plot_AllData <- plot + geom_point() +
  xlab("Longueur (mm)") + ylab("Position trophique") +
  labs(title = "Toutes les données") + fig

Plot_AllData + geom_abline(intercept = -.0009059, slope = 0.4222697)
```

---
# Solution ![:cube]()

b) Figure par espèce

```{r, eval = FALSE}
# mettre les coefs dans un tableau pour les rendre plus faciles à manipuler
Lake.coef <- coef(M8)$Lake
colnames(Lake.coef) <- c("Intercept", "Slope")
Species.coef <- coef(M8)$Fish_Species
colnames(Species.coef) <- c("Intercept", "Slope")

Plot_BySpecies<-plot + geom_point(aes(colour = factor(Fish_Species)), size = 4) +
  xlab("Longueur (mm)") + ylab("Position trophique") +
  labs(title = "Par espèce") + fig

# Ajoutez les lignes de régression pour chaque espèce
Plot_BySpecies +
  geom_abline(intercept = Species.coef[1,1], slope = Species.coef[1,2], col = "coral2") +
  geom_abline(intercept = Species.coef[2,1], slope = Species.coef[2,2], col = "green4") +
  geom_abline(intercept = Species.coef[3,1], slope = Species.coef[3,2], col = "blue1")


```

---
# Solution ![:cube]()

b) Figure par espèce

```{r, echo = F, fig.width=8}
Lake.coef <- as.data.frame(coef(M8)$Lake)
colnames(Lake.coef) <- c("Intercept", "Slope")
Species.coef <- as.data.frame(coef(M8)$Fish_Species)
colnames(Species.coef) <- c("Intercept", "Slope")

Plot_BySpecies<-plot + geom_point(aes(colour = factor(Fish_Species)), size = 4) +
  xlab("Longueur (mm)") + ylab("Position trophique") +
  labs(title = "Par espèce") + fig

# Ajoutez les lignes de régression pour chaque espèce
Plot_BySpecies +
  geom_abline(intercept = Species.coef[1,1], slope = Species.coef[1,2], col = "coral2") +
  geom_abline(intercept = Species.coef[2,1], slope = Species.coef[2,2], col = "green4") +
  geom_abline(intercept = Species.coef[3,1], slope = Species.coef[3,2], col = "blue1")

```

---
# Solution ![:cube]()

c) Figure par lac
```{r, eval= FALSE}
Plot_ByLake<-plot + geom_point(aes(colour = factor(Lake)), size = 4) +
  xlab("Length (mm)") + ylab("Trophic Position") +
  labs(title = "By Lake") + fig

# Ajouter les lignes de régression avec les intercepts spécifiques à chaque lac
Plot_ByLake +
  geom_abline(intercept = Lake.coef[1,1], slope = Lake.coef[1,2], col = "coral2") +
  geom_abline(intercept = Lake.coef[2,1], slope = Lake.coef[2,2], col = "khaki4") +
  geom_abline(intercept = Lake.coef[3,1], slope = Lake.coef[3,2], col = "green4") +
  geom_abline(intercept = Lake.coef[4,1], slope = Lake.coef[4,2], col = "darkgoldenrod") +
  geom_abline(intercept = Lake.coef[5,1], slope = Lake.coef[5,2], col = "royalblue1") +
  geom_abline(intercept = Lake.coef[6,1], slope = Lake.coef[6,2], col = "magenta3")

```

---
# Solution ![:cube]()

c) Figure par lac
```{r, echo = F, fig.width=8}
Plot_ByLake<-plot + geom_point(aes(colour = factor(Lake)), size = 4) +
  xlab("Longueur (mm)") + ylab("Position trophique") +
  labs(title = "par lac") + fig

# Ajouter les lignes de régression avec les intercepts spécifiques à chaque lac
Plot_ByLake +
  geom_abline(intercept = Lake.coef[1,1], slope = Lake.coef[1,2], col = "coral2") +
  geom_abline(intercept = Lake.coef[2,1], slope = Lake.coef[2,2], col="khaki4") +
  geom_abline(intercept = Lake.coef[3,1], slope = Lake.coef[3,2], col="green4") +
  geom_abline(intercept = Lake.coef[4,1], slope = Lake.coef[4,2], col="darkgoldenrod") +
  geom_abline(intercept = Lake.coef[5,1], slope = Lake.coef[5,2], col="royalblue1") +
  geom_abline(intercept = Lake.coef[6,1], slope = Lake.coef[6,2], col="magenta3")

```


---
# Modèle mixtes et données en écologie

<br>

Les modèles mixtes sont très utiles pour prendre en compte la structure complexe des données en écologie tout en permettant de ne pas perdre beaucoup de degrés de liberté

.center[
![](images/fig_1_qcbs_wiki.png)
]


---
# Défi 8 ![:cube]()

<br>

**Situation:**

* Vous avez inventorié la richesse **dans 1000 quadrats** qui sont dans **10 sites différents** qui sont également dans **10 forêts différentes**.

* Vous avez de plus **mesuré la productivité** dans chaque **quadrat**.

* Vous désirez savoir si la productivité est un bon prédicteur de biodiversité

.alert[Quel modèle mixte pourriez-vous utiliser pour ce jeu de données?]

---
# Solution! ![:cube]()

<br>

```{r, eval = FALSE}
lmer(Biodiv ~ Productivite + (1 | Foret / Site))
```

Ici les effets aléatoires sont nichés (i.e. Sites dans forêt) et non croisés.
Pourquoi utiliser `(1 | Foret / Site)` plutôt que `(1 | Foret) + (1 | Site)` ?
Regardez [cette réponse sur ![:faic](stack-exchange)](https://stats.stackexchange.com/questions/228800/crossed-vs-nested-random-effects-how-do-they-differ-and-how-are-they-specified)!


---
# Défi 9 ![:cube]()

<br>

**Situation:**

* Vous avez récolté **200 poissons** dans **12 sites différents** distribués également dans **4 habitats** différents qui se retrouvent dans **un même lac**.

* Vous avez mesuré la **longueur de chaque poisson** et la **quantité de mercure dans ses tissus**.

* Vous désirez savoir si l'habitat est un bon prédicteur de la concentration en mercure.

.alert[Quel modèle mixte pourriez-vous utiliser pour ce jeu de données?]

---
# Solution!![:cube]()

<br>


```{r, eval = FALSE}
lmer(Mercure ~ Longueur * Habitat + (1 | Site))
```




---
# Défi 10![:cube]()

* Discutez du jeu de données sur lequel vous travaillez avec votre voisin et déterminez si un modèle mixte serait approprié.

* Si oui, travaillez ensemble pour écrire le code que vous utiliseriez pour faire ce modèle dans R.

* Si non, imaginez un jeu de données fictif pour lequel un modèle mixte serait approprié et codez ce modèle.


---
# Modèles Linéaires Généralisés Mixtes (GLMMs)

Extension des GLMs tenant compte de structures supplémentaires dans les données

Suivre les étapes similaires à celles introduites lors de l'atelier sur les LMMs:

1. LMMs incorporent les effets aléatoires
2. GLMs peuvent gérer des données non-normales (en laissant les erreurs prendre différentes familles de distribution - e.g Poisson ou binomial négatif)

---
# Comment modéliser un GLM sous R

Chargez les données `Arabidopsis` `banta_totalfruits.csv` dans R.

```{r, echo=FALSE}
dat.tf <- read.csv("data/banta_totalfruits.csv")
```

```r
dat.tf <- read.csv("banta_totalfruits.csv")
```
```r
# popu facteur avec un niveau pour chaque population
# gen facteur avec un niveau pour chaque génotype
# nutrient facteur avec niveau bas (valeur = 1) ou haut (valeur = 8)
# amd facteur précisant l'absence ou la présence d'herbivorie
# total.fruits nombre entier indiquant le nombre de fruits par plante
```

L'effet de la disponibilité de nutriments et d'herbivorie (**effets fixes**) sur la production de fruits d'*Arabidopsis thaliana* (arabette des dames) a été évalué en mesurant 625 plantes à travers neuf populations différentes, constituées chacune de 2 à 3 génotypes (**effets aléatoires**)


---
# Choisir la distribution des erreurs

La variable réponse constitue des données d'abondance, donc nous devons choisir une **distribution de Poisson** (i.e variance égale à la moyenne)

```{r,echo=F, fig.height=5, fig.width=6}
par(mypar);par(cex = 1.4)
hist(dat.tf$total.fruits, breaks = 50, col = 'blue', main = '',
     xlab = 'Fruits totaux', ylab = 'Compte')
```
Cependant, comme nous le verrons, la variance de chaque groupe augmente beaucoup plus rapidement que prévu...

---
# Exploration de la variance

Pour illustrer l'hétérogénéité de la variance, nous allons d'abord créer des boîtes à moustaches (boxplots) de la variable réponse par rapport aux différents facteurs environnementaux

Créons de nouvelles variables qui représentent toutes les combinaisons de **nutriments** x **herbivorie** x **facteur aléatoire**

```{r}
dat.tf <- within(dat.tf,
{
  # génotype x nutriment x herbivorie
  gna <- interaction(gen,nutrient,amd)
  gna <- reorder(gna, total.fruits, mean)
  # population x nutriment x herbivorie
  pna <- interaction(popu,nutrient,amd)
  pna <- reorder(pna, total.fruits, mean)
})
```

---
# Exploration de la variance

.small[
```{r, fig.height=3.5, fig.width=8}
# Boxplot du total des fruits vs interaction génotype x nutriment x herbivorie
library(ggplot2)
ggplot(data = dat.tf, aes(factor(x = gna),y = log(total.fruits + 1))) +
  geom_boxplot(colour = "skyblue2", outlier.shape = 21,
  outlier.colour = "skyblue2") +
  theme_bw() + theme(axis.text.x=element_blank()) +
  stat_summary(fun.y=mean, geom="point", colour = "red")
```
]

.comment[De même, la boîte à moustaches total des fruits vs population x nutriments x herbivorie montre une grande quantité d'hétérogénéité entre les populations.]


---
# Choisir la distribution des erreurs

Comme nous venons de le voir, il existe une importante hétérogénéité parmi la variance de chaque groupe, même lorsque la variable réponse est transformée

Si nous représentons graphiquement les **écarts vs moyennes par groupes** (génotypes x nutriment x herbivorie), on voit que la distribution de Poisson est la moins appropriée (i.e. écart augmentent beaucoup plus vite que la moyenne)

.small[.pull-left[
![](images/errDist.png)
]
.pull-right[

<font color="blue">NB = negative binomial</font>

<br>

<font color="red">QP = quasi-Poisson</font>

<br>
<font color="LightBlue">loess = Locally weighted regression smoothing</font>
]]


---
# GLMM Poisson

Compte tenu de la relation moyenne-variance, nous avons besoin d'un modèle avec surdispersion.

- Mais commençons avec un modèle de Poisson :

Pour lancer un GLMM dans R, nous faisons appel à la fonction `glmer()`, du paquet lme4

```{r}
library(lme4)
mp1 <- glmer(total.fruits ~ nutrient*amd + rack + status +
             (1|popu)+
             (1|gen),
             data = dat.tf, family = "poisson")
```

**Effets aléatoires** : `(1|popu)` contient un intercept aléatoire partagé par les mesures qui ont la même valeur pour `popu`

---
# Vérification de la surdispersion

Nous pouvons vérifier la surdispersion en utilisant la fonction `overdisp_fun()` (Bolker *et al*. 2011) qui divise la déviance des résidus (résidus de Pearson) par les degrés de liberté des résidus et teste si le rapport est plus grand que 1

```{r}
# Téléchargez le code glmm_funs.R de la page wiki et sourcez le pour exécuter la fonction dans R
source(file="data/glmm_funs.R")
# Surdispersion?
overdisp_fun(mp1)
```

- Ratio est significativement $>>$ 1
- Comme on s'y attendait, nous devons modéliser une distribution différente où la variance augmente plus rapidement que la moyenne

---
# GLMM binomiale negative .small[(Poisson-gamma)]

La distribution binomiale négative satisfait la supposition que la **variance est proportionnelle au carré de la moyenne**

```{R}
mnb1 <- glmer.nb(total.fruits ~ nutrient*amd + rack + status +
                 (1|popu)+
                 (1|gen),
                 data=dat.tf, control=glmerControl(optimizer="bobyqa"))
# Control spécifie la façon dont nous optimisons les valeurs des paramètres
```

.pull-left[
```r
# Surdispersion?
overdisp_fun(mnb1)
```
]
.pull-right[
![:faic](arrow-left).small[.alert[Le rapport est maintenant beaucoup plus près de 1 mais la valeur de p < 0.05]]
]

---
# GLMM Poisson-lognormal

- Un autre option est la distribution **Poisson-lognormal**.
- Cela peut être réalisé simplement en plaçant un effet aléatoire de niveau d'observation dans la formule.
.small[
```{r}
mpl1 <- glmer(total.fruits ~ nutrient*amd + rack + status +
              (1|X) +
              (1|popu)+
              (1|gen),
data=dat.tf, family="poisson",
control = glmerControl(optimizer = "bobyqa"))
```

`(1|X)` traite de la surdispersion en ajoutant des **effets aléatoires au niveau de l'observation**

```{r}
overdisp_fun(mpl1)
```

.alert[Rapport maintenant conforme avec notre critère]
]

---
# GLMM Poisson-lognormal

**Représentation graphique des paramètres du modèle**: Une représentation graphique des paramètres du modèle peut être obtenue en utilisant la fonction `coefplot2()`du paquet `coefplot2`:

--

.alert[![:faic](warning) Ce paquet n'est pas sur le CRAN! On utilise le package remotes pour l'installer depuis GitHub]

```{R install_coefplot2}
if (!require("coefplot2"))
  remotes::install_github("palday/coefplot2", subdir = "pkg")
library(coefplot2)
```

---
# GLMM Poisson-lognormal


.pull-left[
```{r, fig.height=5, fig.width=6, echo=-1}
par(mypar);par(cex = 1.4)
# Paramètres de la variance
coefplot2(mpl1, ptype = "vcov", intercept = TRUE)
```
]
.pull-right[
```{r, fig.height=5, fig.width=6,echo=-1}
par(mypar);par(cex = 1.4)
# Effets fixes
coefplot2(mpl1, intercept = TRUE)
```
]

.alert[Note]: barres d'erreur visibles seulement pour les effets fixes parce que glmer ne nous donne pas d'informations sur l'incertitude des effets aléatoires.

---
# Visualisation des effets aléatoires

Vous pouvez aussi extraire les effets aléatoires en utilisant la fonction `ranef()` et les tracer en utilisant un `dotplot()` du paquet `lattice`

Il y a une variabilité régionale parmi les populations :

- Les populations espagnoles (SP) ont des valeurs plus élevées que les populations suédoises (SW) et néerlandaises (NL)

La différence entre les génotypes semble largement induite par génotype 34

```r
library(gridExtra)
library(lattice)
# dotplot code
pp <- list(layout.widths=list(left.padding=0, right.padding=0),
           layout.heights=list(top.padding=0, bottom.padding=0))
r2 <- ranef(mpl1, condVar = TRUE)
d2 <- dotplot(r2, par.settings = pp)
grid.arrange(d2$gen, d2$popu, nrow = 1)
```

---
# Visualisation des effets aléatoires

<br>

```{r, echo= FALSE, fig.width=9}
library(gridExtra)
library(lattice)
pp <- list(layout.widths=list(left.padding=0, right.padding=0),
           layout.heights=list(top.padding=0, bottom.padding=0))
r2 <- ranef(mpl1, condVar = TRUE)
d2 <- dotplot(r2, par.settings = pp, scales=list(x=list(cex=1.4),y=list(cex=1.3)))
grid.arrange(d2$gen, d2$popu, nrow = 1)
```


---
# Sélection du modèle

Les même méthodes peuvent être utilisées avec un glmm ou lmm pour choisir entre des modèles avec différents intercepts aléatoires et/ou des pentes aléatoires et pour choisir les effets fixes à conserver dans le modèle final.

- une **approche de la théorie de l'information** (e.g., AICc - Atelier 5)
- une **approche fréquentiste** (où l'importance de chaque terme est évaluée en utilisant `anova()` et le test de rapport de vraisemblance; LRT)


---
# Sélection du modèle

Nous dérivons d'abord les modèles potentiels et les comparons en utilisant AICc.comment[*]:

```{r}
mpl2 <- update(mpl1, . ~ . - rack) # modèle sans rack
mpl3 <- update(mpl1, . ~ . - status) # modèle sans status
mpl4 <- update(mpl1, . ~ . - amd:nutrient) # modèle sans interaction amd:nutrient
bbmle::ICtab(mpl1, mpl2, mpl3, mpl4, type = c("AICc"))
```

.comment[*NB: Nous ne couvrons pas tous les modèles possibles ci-dessus, cependant, l'interaction `amd:nutriments` ne peut être évaluée que si amd et nutriments sont présents dans le modèle.
]


---
# Sélection du modèle

Nous pouvons aussi utiliser les fonctions `drop1()` et `dfun()` pour évaluer nos effets fixes (`dfun()` convertit les valeurs AIC retournées par `drop1()` en valeurs $\Delta$AIC)

.small[
```{r}
dd_LRT <- drop1(mpl1,test="Chisq")
(dd_AIC <- dfun(drop1(mpl1)))
```
]

---
# Sélection du modèle
.small[
```{r}
dd_LRT <- drop1(mpl1,test="Chisq")
(dd_AIC <- dfun(drop1(mpl1)))
```
]

- Fort effet de **rack** (dAIC = 55.08 si on enlève cette variable)
- Effets de **status** et de l'**interaction** sont faibles (dAIC < 2)
- Commençons par **enlever l'interaction non significative** afin de tester les effets principaux de nutriments et d'herbivorie

---
# Sélection du modèle

<br>

.pull-left2[
```{r}
mpl2 <- update(mpl1, . ~ . - and:nutrient)
# Utiliser AIC
mpl3 <- update(mpl2, . ~ . - rack) # pas de rack ou interaction
mpl4 <- update(mpl2, . ~ . - status) # pas de status ou interaction
mpl5 <- update(mpl2, . ~ . - nutrient) # pas de nutrient ou interaction
mpl6 <- update(mpl2, . ~ . - amd) # pas d'herbivorie ou interaction
# bbmle::ICtab(mpl2, mpl3, mpl4, mpl5, mpl6,
#              type = c("AICc"))

# Ou utiliser drop1
dd_LRT2 <- drop1(mpl2,test="Chisq")
dd_AIC2 <- dfun(drop1(mpl2))
```
]
.pull-right2[
```{r}
library(bbmle)
ICtab(mpl2, mpl3 ,mpl4,
      mpl5, mpl6,
      type = c("AICc"))
```
]


---
# Sélection du modèle
<br>

- Fort effets de **nutriments** et d'**herbivorie** (grand changement d'AIC de $135.6$ (`mpl5`) et $10.2$ (`mpl6`) si l'un ou l'autre sont supprimés, respectivement).
- Notre modèle final inclut l'effet fixe de nutriments, d'herbivorie, la variable nuisance de rack, l'effet aléatoire au niveau de l'observation `(1|X)` et la variation de fruits par populations et génotypes.


---
# Prêt pour un défi? ![:cube]()

En utilisant l'ensemble de données `inverts` (temps de développement larvaire (`PLD`) de 74 espèces d'invertébrés et vertébrés marins élevés à différentes températures et temps), répondez aux questions suivantes:

- Quel est l'effet du type d'alimentation et du climat (**effets fixes**) sur `PLD`?
- Est-ce que cette relation varie selon les taxons (**effets aléatoires**)?
- Quelle est la **meilleure famille de distributions** pour ces données?
- Finalement, une fois que vous avez déterminé la meilleure famille de distribution, re-évaluez vos effets fixes et aléatoires.


---
# Solution

```{R, eval = FALSE}
# inverts <- read.csv('data/inverts.csv', header = TRUE)
# head(inverts)
# table(inverts$temp, inverts$feeding.type)
#
# mod.glm <- glm(PLD ~ temp + feeding.type, family = poisson(), data = inverts)
# summary(mod.glm)
# drop1(mod.glm, test = "Chisq")
#
# boxplot(PLD ~ temp,  data = inverts)
# boxplot(PLD ~ feeding.type ,  data = inverts)
#
# boxplot(predict(mod.glm, type = "response")~inverts$temp)
#
# plot()
#
# modglm <- glm(PLD ~ temp + feeding.type, family = poisson(), data = inverts)


#
# r2 <- ranef(mpl1, condVar = TRUE)
# d2 <- dotplot(r2, par.settings = pp)
#
#
# plot(aggregate(PLD ~ taxon, FUN=mean, data = inverts)[,2],aggregate(PLD ~ taxon, FUN=var, data = inverts)[,2], pch = 19)
# abline(a=0, b = 1, lty =2)
#
# mod.glmer <- glmer.nb(PLD ~ temp + feeding.type + (1|taxon), data = inverts)
# mod.glm <- glm.nb(PLD ~ temp + feeding.type, family = poisson(), data = inverts)

```

plot(aggregate(PLD ~ taxon, FUN=var, data = inverts)[,2],aggregate(PLD ~ taxon, FUN=mean, data = inverts)[,2])
abline(a=0, b =1, lty =2 )



---
# Ressources additionnelles

* Différences entre `nlme` et `lme4`

.center[
![:scale 25%](images/book1.jpg) ![:scale 28%](images/book2.jpg)
]

* [Harrison et al. (2018), PeerJ, DOI 10.7717/peerj.4794
](http://dx.doi.org/10.7717/peerj.4794)


---
class: inverse, center, bottom

# Merci de votre participation à cet atelier!

![:scale 50%](images/qcbs_logo.png)


<!-- https://stats.stackexchange.com/questions/64226/lme-and-lmer-comparison -->